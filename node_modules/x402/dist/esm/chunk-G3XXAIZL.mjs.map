{"version":3,"sources":["../../src/schemes/exact/index.ts","../../src/schemes/exact/evm/index.ts","../../src/schemes/exact/evm/facilitator.ts"],"sourcesContent":["export * as evm from \"./evm\";\n\nexport const SCHEME = \"exact\";\n","export * from \"./client\";\nexport * from \"./facilitator\";\nexport * from \"./utils/paymentUtils\";\n","import { Account, Address, Chain, getAddress, Hex, Transport, verifyTypedData } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport { getVersion, getERC20Balance } from \"../../../shared/evm\";\nimport {\n  usdcABI as abi,\n  authorizationTypes,\n  config,\n  ConnectedClient,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n} from \"../../../types/verify\";\nimport { SCHEME } from \"../../exact\";\n\n/**\n * Verifies a payment payload against the required payment details\n *\n * This function performs several verification steps:\n * - Verifies protocol version compatibility\n * - Validates the permit signature\n * - Confirms USDC contract address is correct for the chain\n * - Checks permit deadline is sufficiently in the future\n * - Verifies client has sufficient USDC balance\n * - Ensures payment amount meets required minimum\n *\n * @param client - The public client used for blockchain interactions\n * @param payload - The signed payment payload containing transfer parameters and signature\n * @param paymentRequirements - The payment requirements that the payload must satisfy\n * @returns A ValidPaymentRequest indicating if the payment is valid and any invalidation reason\n */\nexport async function verify<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined,\n>(\n  client: ConnectedClient<transport, chain, account>,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<VerifyResponse> {\n  /* TODO: work with security team on brainstorming more verification steps\n  verification steps:\n    - ✅ verify payload version\n    - ✅ verify usdc address is correct for the chain\n    - ✅ verify permit signature\n    - ✅ verify deadline\n    - verify nonce is current\n    - ✅ verify client has enough funds to cover paymentRequirements.maxAmountRequired\n    - ✅ verify value in payload is enough to cover paymentRequirements.maxAmountRequired\n    - check min amount is above some threshold we think is reasonable for covering gas\n    - verify resource is not already paid for (next version)\n    */\n\n  // Verify payload version\n  if (payload.scheme !== SCHEME || paymentRequirements.scheme !== SCHEME) {\n    return {\n      isValid: false,\n      invalidReason: `unsupported_scheme`,\n      payer: payload.payload.authorization.from,\n    };\n  }\n\n  let name: string;\n  let chainId: number;\n  let erc20Address: Address;\n  let version: string;\n  try {\n    chainId = getNetworkId(payload.network);\n    name = paymentRequirements.extra?.name ?? config[chainId.toString()].usdcName;\n    erc20Address = paymentRequirements.asset as Address;\n    version = paymentRequirements.extra?.version ?? (await getVersion(client));\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: `invalid_network`,\n      payer: payload.payload.authorization.from,\n    };\n  }\n  // Verify permit signature is recoverable for the owner address\n  const permitTypedData = {\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\" as const,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: erc20Address,\n    },\n    message: {\n      from: payload.payload.authorization.from,\n      to: payload.payload.authorization.to,\n      value: payload.payload.authorization.value,\n      validAfter: payload.payload.authorization.validAfter,\n      validBefore: payload.payload.authorization.validBefore,\n      nonce: payload.payload.authorization.nonce,\n    },\n  };\n  const recoveredAddress = await verifyTypedData({\n    address: payload.payload.authorization.from as Address,\n    ...permitTypedData,\n    signature: payload.payload.signature as Hex,\n  });\n  if (!recoveredAddress) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_signature\", //\"Invalid permit signature\",\n      payer: payload.payload.authorization.from,\n    };\n  }\n\n  // Verify that payment was made to the correct address\n  if (getAddress(payload.payload.authorization.to) !== getAddress(paymentRequirements.payTo)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n      payer: payload.payload.authorization.from,\n    };\n  }\n\n  // Verify deadline is not yet expired\n  // Pad 3 block to account for round tripping\n  if (\n    BigInt(payload.payload.authorization.validBefore) < BigInt(Math.floor(Date.now() / 1000) + 6)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\", //\"Deadline on permit isn't far enough in the future\",\n      payer: payload.payload.authorization.from,\n    };\n  }\n  // Verify deadline is not yet valid\n  if (BigInt(payload.payload.authorization.validAfter) > BigInt(Math.floor(Date.now() / 1000))) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\", //\"Deadline on permit is in the future\",\n      payer: payload.payload.authorization.from,\n    };\n  }\n  // Verify client has enough funds to cover paymentRequirements.maxAmountRequired\n  const balance = await getERC20Balance(\n    client,\n    erc20Address,\n    payload.payload.authorization.from as Address,\n  );\n  if (balance < BigInt(paymentRequirements.maxAmountRequired)) {\n    return {\n      isValid: false,\n      invalidReason: \"insufficient_funds\", //\"Client does not have enough funds\",\n      payer: payload.payload.authorization.from,\n    };\n  }\n  // Verify value in payload is enough to cover paymentRequirements.maxAmountRequired\n  if (BigInt(payload.payload.authorization.value) < BigInt(paymentRequirements.maxAmountRequired)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_value\", //\"Value in payload is not enough to cover paymentRequirements.maxAmountRequired\",\n      payer: payload.payload.authorization.from,\n    };\n  }\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer: payload.payload.authorization.from,\n  };\n}\n\n/**\n * Settles a payment by executing a USDC transferWithAuthorization transaction\n *\n * This function executes the actual USDC transfer using the signed authorization from the user.\n * The facilitator wallet submits the transaction but does not need to hold or transfer any tokens itself.\n *\n * @param wallet - The facilitator wallet that will submit the transaction\n * @param paymentPayload - The signed payment payload containing the transfer parameters and signature\n * @param paymentRequirements - The original payment details that were used to create the payload\n * @returns A PaymentExecutionResponse containing the transaction status and hash\n */\nexport async function settle<transport extends Transport, chain extends Chain>(\n  wallet: SignerWallet<chain, transport>,\n  paymentPayload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<SettleResponse> {\n  // re-verify to ensure the payment is still valid\n  const valid = await verify(wallet, paymentPayload, paymentRequirements);\n\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: paymentPayload.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\", //`Payment is no longer valid: ${valid.invalidReason}`,\n      payer: paymentPayload.payload.authorization.from,\n    };\n  }\n\n  const tx = await wallet.writeContract({\n    address: paymentRequirements.asset as Address,\n    abi,\n    functionName: \"transferWithAuthorization\" as const,\n    args: [\n      paymentPayload.payload.authorization.from as Address,\n      paymentPayload.payload.authorization.to as Address,\n      BigInt(paymentPayload.payload.authorization.value),\n      BigInt(paymentPayload.payload.authorization.validAfter),\n      BigInt(paymentPayload.payload.authorization.validBefore),\n      paymentPayload.payload.authorization.nonce as Hex,\n      paymentPayload.payload.signature as Hex,\n    ],\n    chain: wallet.chain as Chain,\n  });\n\n  const receipt = await wallet.waitForTransactionReceipt({ hash: tx });\n\n  if (receipt.status !== \"success\") {\n    return {\n      success: false,\n      errorReason: \"invalid_transaction_state\", //`Transaction failed`,\n      transaction: tx,\n      network: paymentPayload.network,\n      payer: paymentPayload.payload.authorization.from,\n    };\n  }\n\n  return {\n    success: true,\n    transaction: tx,\n    network: paymentPayload.network,\n    payer: paymentPayload.payload.authorization.from,\n  };\n}\n"],"mappings":"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","names":[]}